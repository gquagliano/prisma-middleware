/**
 * Returns all models by name.
 * @param {Prisma} Prisma - Prisma Client class.
 * @returns {object}
 */
function getModels(Prisma) {
    const models = Prisma.dmmf.datamodel.models;

    let byName = {};

    for(let model of models)
        byName[model.name] = model;

    return byName;
}

/**
 * Returns one field definition.
 * @param {Prisma} Prisma - Prisma Client class.
 * @param {string} modelName - Model name.
 * @param {string} fieldName - Field name.
 * @returns {object}
 */
function getField(Prisma, modelName, fieldName) {
    return getModels(Prisma)[modelName].fields.find(field => field.name == fieldName);
}

/**
 * Returns the list of fields from a model, by name. 
 * @param {Prisma} Prisma - Prisma Client class.
 * @param {string} modelName - Model name.
 * @returns {object}
 */
function getFieldTypes(Prisma, modelName) {
    let fields = {},
        relationalFields = [];

    const modelFields = getModels(Prisma)[modelName].fields;

    for(let field of modelFields)
        if(field.relationFromFields)
            relationalFields = [...relationalFields, ...field.relationFromFields];

    for(let field of modelFields) {
        let { name, type, kind, relationName, isRequired } = field,
            relatedModelName;

        if(relationName)
            relatedModelName = type;

        if(kind == "object")
            type = "Object";

        if(relationalFields.includes(name))
            type = "Id";

        fields[name] = {
            type,
            relational: !!relationName,
            relatedModelName,
            allowNull: !isRequired
        };
    }

    return fields;
}

/**
 * Transforms a value according to the properties of a field.
 * @param {*} value - Original value.
 * @param {object} field - Field definition, as generated by getFieldTypes().
 * @returns {*}
 */
function cast(value, field) {
    if(field.allowNull && (value === null || typeof value == "undefined"))
        return null;

    if(field.type == "Id") {
        value = parseInt(value);
        return value > 0
            ? value
            : null;
    }

    if(field.type == "Int")
        return parseInt(value) || 0;

    if(field.type == "String")
        return (value || "").toString();

    if(field.type == "Boolean") {
        return !!value;
    }

    if(field.type == "Decimal")
        return parseFloat(value) || 0;

    //type == "Object" => nothing to do

    //TODO other types?

    return value;
}

/**
 * Walks an array or object looking for fields to transform.
 * @param {Prisma} Prisma - Prisma Client class.
 * @param {*} obj - Object to traverse.
 * @param {string} modelName - Model name.
 */
function castRecursive(Prisma, obj, modelName) {
    if(!obj)
        return;

    if(Array.isArray(obj)) {
        for(let elem of obj)
            castRecursive(Prisma, elem, modelName);
        return;
    }

    if(typeof obj == "object") {
        const fields = getFieldTypes(Prisma, modelName);

        for(let key of Object.keys(obj)) {
            if(typeof obj[key] == "object")
                castRecursive(Prisma, obj[key], modelName);
            else if(fields[key])
                obj[key] = cast(obj[key], fields[key]);
        }
    }
}

/**
 * Walks the query arguments looking for nested `where` and `data` objects to process.
 * @param {Prisma} Prisma - Prisma Client class.
 * @param {*} obj - Object to traverse.
 * @param {string} modelName - Current level model name.
 */
function walkArgs(Prisma, obj, modelName) {
    if(typeof obj != "object")
        return;

    const fields = getFieldTypes(Prisma, modelName);

    for(let key of Object.keys(obj)) {
        if(key == "where" || key == "data") {
            castRecursive(Prisma, obj[key], modelName);
            continue;
        }

        if(typeof obj[key] == "object") {
            let model = fields[key] && fields[key].relational
                ? fields[key].relatedModelName
                : modelName;

            walkArgs(Prisma, obj[key], model);
            continue;
        }
    }
}

/**
 * Adds automatic type casting to field values in `where` and `data`s to Prisma Client.
 * @param {Prisma} Prisma - Prisma Client class.
 * @param {PrismaClient} PrismaClient - Prisma Client instance.
 * @returns {PrismaClient}
 */
function useAutoCast(Prisma, PrismaClient) {
    PrismaClient.$use(async (params, next) => {
        if(params.model && ["create", "update", "updateMany", "findUnique", "findFirst", "findMany"].includes(params.action))
            walkArgs(Prisma, params.args, params.model);

        let result = await next(params);

        //If we want to transform the results too (maybe in the future):
        //for(let key of Object.keys(result)) {
        //    if(result[key] instanceof Prisma.Decimal)
        //        result[key] = result[key].toNumber();
        //}

        return result;
    });

    return PrismaClient;
}

module.exports = {
    useAutoCast
};